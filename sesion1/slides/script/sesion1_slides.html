<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
  <head>
    <title>Cómo sobrevivir a una pelea con R</title>
    <meta charset="utf-8" />
    <meta name="author" content="" />
    <link href="libs/font-awesome/css/fontawesome-all.min.css" rel="stylesheet" />
    <script src="libs/htmlwidgets/htmlwidgets.js"></script>
    <script src="libs/d3/d3.min.js"></script>
    <script src="libs/dagre/dagre-d3.min.js"></script>
    <link href="libs/mermaid/dist/mermaid.css" rel="stylesheet" />
    <script src="libs/mermaid/dist/mermaid.slim.min.js"></script>
    <link href="libs/DiagrammeR-styles/styles.css" rel="stylesheet" />
    <script src="libs/chromatography/chromatography.js"></script>
    <script src="libs/DiagrammeR-binding/DiagrammeR.js"></script>
    <script src="libs/kePrint/kePrint.js"></script>
    <link href="libs/ionicons/css/ionicons.min.css" rel="stylesheet" />
    <link rel="stylesheet" href="xaringan-themer.css" type="text/css" />
  </head>
  <body>
    <textarea id="source">
class: left, middle, inverse, title-slide

# Cómo sobrevivir a una pelea con R
## Curso de introducción a R
### Pablo Cabrera-Álvarez <br> <span style="font-size: 75%;"><a href="https://github.com/pablocal"><i class="fab  fa-github "></i></a> | <a href="https://twitter.com/pablocalv"><i class="fab  fa-twitter "></i></a> <span class="citation">@pablocalv</span> </span> <br>
### <br><br>Julio 2019

---



# El curso

1. Cómo sobrevivir a una pelea con `R`    
 

--
2. Manipulación de datos, lo básico pero en `R`    
 

--
3. Manipulación de datos, más allá de lo básico   

--
 
4. *Outputs*: ¿Y todo esto para hacer una tabla?    
 
 
--
     
     
----
    
    
- Proyecto: Crear una BD a partir de fuentes web

---
# Dinámica de trabajo

--

 - **Reproducir** `\(\to\)` **Aplicar** `\(\to\)` **Insertar**    

--

 - **Jugar** con vuestros propios datos    
 
--

 - Dudas a [pablocal@usal.es](mailto:pablocal@usal.es) | [@pablocalv](https://twitter.com/pablocalv)    
 
--

 - En `R` hay que **perderse**    
 
--

- ¿Para qué es `R` útil?    

--

- Materiales y todo el **código** disponible en  [<i class="fab  fa-github "></i>](https://github.com/pablocal/course_introR)


---
background-image: url(http://bit.ly/2XGHKmb)

# Cómo sobrevivir a una pelea con `R`



---
# Cómo sobrevivir a una pelea con `R`

- Tipos de **objetos en `R`**: vectors, matrices, data frames, lists, functions

--

- **Indexación** en `R` `\(\to\)` `[]`, `$`, `[[]]`:
  * Vectors
  * Matrices
  * Data frames
  * Lists

--

- **Modificar** vectores en `R`:
  * Operadores
  * Factors
  * Character
  * Dates
  * Valores **perdidos** en `R`

--

- **Transformar objetos**: `class()` y `as._()`

--

- **Proyecto** y workflow en `R`

---
# Antes de empezar, consejos generales 🤓


- Empezar un script (`.R`)
  * Título y metadatos
  * Limpiar el espacio
  * Cargar paquetes que van a ser usados
  

```r
########## CURSO DE R - Sesión 1: Objetos #############
# by PCA on 15th jul. 19

rm(list = ls()) # limpiar el espacio

library(tidyverse) # carga paquete tidyverse
library(lubridate) # carga paquete lubridate
```
  
---
# Antes de empezar, consejos generales 🤓

- Nombrar objetos
  * 2Cs: Conciso y consistente
  * Minúscula
  * Estilos: `sexoEdad`, `sexo_edad` o `sexo.edad`    

--

- Comentar `#` [`Ctrl` + `C`]
  * Explicar el por qué
  * Usar separadores para organizar el scrip [`Ctrl` + `Mayús` + `R`]

--

- Espacios  
  * Usar espacios en torno a los operadores
  * Evitar espacios en el principio/final de los paréntesis
  

```r
a&lt;-22+23 # mal
a &lt;- 22 + 23 # bien
```
  
---
# Directorio de trabajo

#### `setwd(dir)` | `getwd()`

Antes de comenzar a trabajar en `R` es preciso **designar una carpeta de trabajo**, para lo que existen dos opciones.

--

La primera opción es utilizar un **proyecto de `RStudio`**, que fijará el directorio de trabajo en la carpeta escogida:

`File` `\(\to\)` `New project...` `\(\to\)` `New directory`

--

La segunda opción consiste en **fijar manualmente el directorio**&lt;sup&gt;1&lt;/sup&gt; de trabajo con la función `setwd(dir)`. Para conocer el directorio de trabajo actual se puede utilizar `getwd()`.


```r
setwd("c:/user/pablo/documentos/mi proyecto de R")
```

.footnote[
[1] Nótese el sentido de las barras (`/`).
]
 
---
class: inverse, center, middle 

# Objetos en R

---
# `R` como lenguaje orientado a objetos

R es un **lenguaje orientado a objetos**: todos los elementos son almacenables como un objeto...



```r
number_a &lt;- 5
number_b &lt;- 2
```


...y los objetos pueden ser utilizados posteriormente en otras operaciones:


```r
number_c &lt;- number_a*number_b

number_c
```

```
## [1] 10
```

---
# Objetos en `R`

<div id="htmlwidget-8964d625cf1ad9667b59" style="width:504px;height:504px;" class="DiagrammeR html-widget"></div>
<script type="application/json" data-for="htmlwidget-8964d625cf1ad9667b59">{"x":{"diagram":"\ngraph LR\nA((Objetos R))-->B[Vector]\nA-->C[Matrix]\nA-->D[Data frame]\nA-->E[List]\n\nstyle B fill:#00758f\n"},"evals":[],"jsHooks":[]}</script>


---
# Vector

<div id="htmlwidget-3a5c75c97ce94e33210e" style="width:504px;height:504px;" class="DiagrammeR html-widget"></div>
<script type="application/json" data-for="htmlwidget-3a5c75c97ce94e33210e">{"x":{"diagram":"\ngraph LR\nA((Vector))-->B[Numeric] \nA-->G[Character]\nA-->H[Logical]\nA-->I[Factor]\nA-->J[Date]\nB-->K[Integer]\nB-->L[Double]\n\nstyle A fill:#00758f\n\n"},"evals":[],"jsHooks":[]}</script>

---

# Vectores

#### `c()` | `names()`

Un **vector** es el objeto básico de `R`, un conjunto de números o caracteres. Todos los elementos de un vector deben de ser del mismo tipo. 


```r
my_vector &lt;- c(10, 20, 10) # crear objeto mi_vector
```


Para **imprimir el vector**, simplemente ejecutar el nombre:


```r
my_vector # imprimir mi_vector
```

```
## [1] 10 20 10
```


Los elementos de los vectores pueden tener **atributos**, como **nombres**:


```r
*names(my_vector) &lt;- c("Juan", "Marta", "Pablo") # asignar nombres
my_vector # imprimir vector con nombres
```

```
##  Juan Marta Pablo 
##    10    20    10
```

---
# Numeric

Los vectores **integer** están compuestos por números enteros:

```r
vector_integer &lt;- c(1, 2, 5)
vector_integer
```

```
## [1] 1 2 5
```


Los vectores de tipo **double** están compuestos por números decimales:

```r
vector_double &lt;- c(1.87, 2, 5.8754)
vector_double
```

```
## [1] 1.8700 2.0000 5.8754
```

---
# Character 

Los vectores **character** contienen cadenas de texto:

```r
vector_character &lt;- c("Hola", "Casa", "Terreno en Madrid")
vector_character 
```

```
## [1] "Hola"              "Casa"              "Terreno en Madrid"
```

---
# Logical

Los vectores de tipo **logical** contienen los elemento *booleanos* `TRUE` y `FALSE`:

```r
vector_logical &lt;- c(TRUE, FALSE, TRUE)
vector_logical
```

```
## [1]  TRUE FALSE  TRUE
```

---
# Factor

#### `factor(x, levels, labels, ordered)` | `str(x)`

Los **factores** son un tipo concreto de vector en el que unos **valores numéricos son asociados a unas etiquetas**.


```r
## 1 = Trabaja, 2 = Desemp., 3 = Retirado  
vector_values &lt;- c(1, 2, 2, 3, 1, 2)

value_factor &lt;- factor(vector_values, levels = c(1, 2, 3), 
                       labels = c("Trabaja", "Desemp.", "Retirado"))
str(value_factor) 
```

```
##  Factor w/ 3 levels "Trabaja","Desemp.",..: 1 2 2 3 1 2
```

---
# Factor

Los factores también pueden ser generados a partir de vectores de tipo *character*. En ese caso los **levels** son obtenidos de las categorías de texto del vector.


```r
vector_labels &lt;- c("Trabaja", "Desemp.", "Trabaja", "Trabaja", "Retirado")

labels_factor &lt;- factor(vector_labels)
str(labels_factor)
```

```
##  Factor w/ 3 levels "Desemp.","Retirado",..: 3 1 3 3 2
```

---
# Quiz 📝

En el siguiente vector lógico: `c(TRUE, TRUE, FALSE)`, ¿cuál será el resultado de la suma de sus elementos?

--


```r
sum(c(TRUE, TRUE, FALSE))
```

```
## [1] 2
```

---
# Objetos en `R`

<div id="htmlwidget-fb94c31a7339b665b54d" style="width:504px;height:504px;" class="DiagrammeR html-widget"></div>
<script type="application/json" data-for="htmlwidget-fb94c31a7339b665b54d">{"x":{"diagram":"\ngraph LR\nA((Objetos R))-->B[Vector]\nA-->C[Matrix]\nA-->D[Data frame]\nA-->E[List]\n\nstyle C fill:#00758f\n"},"evals":[],"jsHooks":[]}</script>
---

# Matrix 
#### `matrix(x, nrow, ncol)`

Los **matrices** son un conjunto de datos del mismo tipo organizados en más de una dimensión:
  

```r
my_matrix &lt;- matrix(1:20, nrow = 4) # genera una matriz (4 × 5)
my_matrix
```

```
##      [,1] [,2] [,3] [,4] [,5]
## [1,]    1    5    9   13   17
## [2,]    2    6   10   14   18
## [3,]    3    7   11   15   19
## [4,]    4    8   12   16   20
```

---
# Objetos en `R`


<div id="htmlwidget-48b5f51c6f756195cf33" style="width:504px;height:504px;" class="DiagrammeR html-widget"></div>
<script type="application/json" data-for="htmlwidget-48b5f51c6f756195cf33">{"x":{"diagram":"\ngraph LR\nA((Objetos R))-->B[Vector]\nA-->C[Matrix]\nA-->D[Data frame]\nA-->E[List]\n\nstyle D fill:#00758f\n"},"evals":[],"jsHooks":[]}</script>
---

# Data frame

#### `data.frame(..., stringsAsFactors = TRUE)` | `rnorm(n, mean = 1, sd = 0)` | `runif(n, min = 0, max = 1)`

Los **data frames** son conjuntos de datos en los que las columnas pueden ser vectores de diferente tipo. Equiparable al conjunto de datos estándar utilizado en las Ciencias Sociales, **casos** en las **filas** y **variables** en las **columnas**.



```r
my_df &lt;- data.frame(var_char= letters[1:5],
                 var_num = rnorm(5),
                 var_logic = runif(5) &gt; .5)
my_df
```

```
##   var_char   var_num var_logic
## 1        a 0.1527290     FALSE
## 2        b 1.7542460     FALSE
## 3        c 0.1653426      TRUE
## 4        d 0.3585551     FALSE
## 5        e 0.1919246      TRUE
```

---
# Objetos en `R`


<div id="htmlwidget-9ccba52a152c57e9bc77" style="width:504px;height:504px;" class="DiagrammeR html-widget"></div>
<script type="application/json" data-for="htmlwidget-9ccba52a152c57e9bc77">{"x":{"diagram":"\ngraph LR\nA((Objetos R))-->B[Vector]\nA-->C[Matrix]\nA-->D[Data frame]\nA-->E[List]\n\nstyle E fill:#00758f\n"},"evals":[],"jsHooks":[]}</script>

---
## List

#### `list(...)`

Las **listas** son conjuntos de diferentes tipos de elementos (e.g. vectores, matrices, df, funciones, listas...):


```r
my_list &lt;- list(vector = my_vector, df = my_df) # generar lista
my_list
```

```
## $vector
##  Juan Marta Pablo 
##    10    20    10 
## 
## $df
##   var_char   var_num var_logic
## 1        a 0.1527290     FALSE
## 2        b 1.7542460     FALSE
## 3        c 0.1653426      TRUE
## 4        d 0.3585551     FALSE
## 5        e 0.1919246      TRUE
```

---
# Quiz 📝

¿Es posible que una lista contenga otra lista dentro como en el siguiente código?


```r
my_list2 &lt;- list(list_old = my_list, 
                 df = my_df)
```

---
# Function

#### `mean(x, na.rm = FALSE)`

Las **funciones** son las **herramientas** que sirven para trabajar con los datos, también son objetos almacenables, modificables y que pueden ser creadas por el usuario:


```r
mean(my_vector)
```

```
## [1] 13.33333
```


```r
mean_my_vector &lt;- mean(my_vector)
mean_my_vector
```

```
## [1] 13.33333
```

---
# Function

Las **funciones** siempre tienen la misma estructura:

`function(arg1 = x1, arg2 = x2, ...)`

Algunos argumentos son **obligatorios**, otros opcionales; utilizar el nombre del argumento es útil para hacer más legible el código, especialmente en el caso de funciones poco utilizadas.
        

```r
runif(n = 5, min = 0, max = 1)
```

```
## [1] 0.78090196 0.89963252 0.28984664 0.84035160 0.07444386
```

Los argumentos también pueden ser interpretados según su **posición** en la función:


```r
runif(5, 0, 1)
```

```
## [1] 0.58977307 0.93585676 0.07330139 0.04727761 0.12285817
```

Algunos argumentos vienen definidos **por defecto**:

```r
runif(5) # min = 0; max = 1
```

```
## [1] 0.9774446 0.9754467 0.5757741 0.9793299 0.7511847
```
---
# Paquetes de funciones

#### `install.packages(pkgs)` | `library(pkgs)`

Algunas funciones vienen por defecto en `R` (8 paquetes) y otras están en paquetes creados por terceros. Los paquetes se encuentran disponibles en un repositiorio llamado **CRAN**.
  
Para **instalar un paquete**: 


```r
install.packages("package")
```

Una vez instalado, para **cargar un paquete**:


```r
library(package)
```

Alternativamente se puede **extraer una función** de un paquete instalado **sin necesidad de cargarlo**:


```r
package::function()
```


---
class: center, middle, inverse

# Indexar en R

---
# Indexar en R

&lt;table class="table" style="margin-left: auto; margin-right: auto;"&gt;
 &lt;thead&gt;
  &lt;tr&gt;
   &lt;th style="text-align:left;"&gt; Objeto &lt;/th&gt;
   &lt;th style="text-align:left;"&gt; Indexación &lt;/th&gt;
   &lt;th style="text-align:left;"&gt; Ejemplo &lt;/th&gt;
  &lt;/tr&gt;
 &lt;/thead&gt;
&lt;tbody&gt;
  &lt;tr&gt;
   &lt;td style="text-align:left;font-weight: bold;border-right:1px solid;font-weight: bold;color: white !important;background-color: #3C989E !important;"&gt; Vector &lt;/td&gt;
   &lt;td style="text-align:left;width: 50em; width: 40em; font-weight: bold;color: white !important;background-color: #3C989E !important;"&gt; Usar corchetes [] junto con la posición o nombre del elemento &lt;/td&gt;
   &lt;td style="text-align:left;font-weight: bold;color: white !important;background-color: #3C989E !important;"&gt; my_vector[1:2] my_vector['Juan'] &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style="text-align:left;font-weight: bold;border-right:1px solid;"&gt; Matrix &lt;/td&gt;
   &lt;td style="text-align:left;width: 50em; width: 40em; "&gt; Usar corchetes [,] para seleccionar filas y columnas; en blanco equivale a todas las filas o columnas &lt;/td&gt;
   &lt;td style="text-align:left;"&gt; my_matrix[c(1, 3), ] my_matrix[1:3, c(2, 5)] &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style="text-align:left;font-weight: bold;border-right:1px solid;font-weight: bold;color: white !important;background-color: #3C989E !important;"&gt; Data frame &lt;/td&gt;
   &lt;td style="text-align:left;width: 50em; width: 40em; font-weight: bold;color: white !important;background-color: #3C989E !important;"&gt; Dos formas habituales $ y [,]. Con $ se seleccionan las columnas por su nombre, mientras que con [,] se seleccionan las filas, según su posición o alguna característica y columnas según su nombre o posición &lt;/td&gt;
   &lt;td style="text-align:left;font-weight: bold;color: white !important;background-color: #3C989E !important;"&gt; my_df$var_char my_df[1:5, c('var_char', 'var_num')] my_df[my_df$var_logic == TRUE, ] &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style="text-align:left;font-weight: bold;border-right:1px solid;"&gt; List &lt;/td&gt;
   &lt;td style="text-align:left;width: 50em; width: 40em; "&gt; Se utiliza $ y [[]], el primero en caso de que los elementos de la lista tengan nombre, el segundo para extraer los elementos por su posición &lt;/td&gt;
   &lt;td style="text-align:left;"&gt; my_list[[2]] my_list$df &lt;/td&gt;
  &lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

---
# Indexar vectores

<i class="ion  ion-alert "></i> Es recurrente la selección de **elementos dentro de los vectores**. En este caso se quiere seleccionar los valores correspondientes a Marta y Pablo. 


```r
my_vector
```

```
##  Juan Marta Pablo 
##    10    20    10
```
--

<i class="ion  ion-checkmark-circled "></i> Para indexar un vector se utiliza el corchete `[]`. Hay dos formas de hacerlo, si el vector no tiene nombres se utiliza la **posición del elemento**. En el caso de Marta es posición `2` mientras que Pablo está en la posición `3`.


```r
my_vector[2:3]
```

```
## Marta Pablo 
##    20    10
```

---
# Indexar vectores

<i class="ion  ion-checkmark-circled "></i> La otra opción consiste en utilizar **los nombres de los elementos** del vector:


```r
my_vector[c("Marta", "Pablo")]
```

```
## Marta Pablo 
##    20    10
```

---
# Indexar matrices

<i class="ion  ion-alert "></i> A veces es necesario **seleccionar parte de las matrices**. En este caso se seleccionará las filas 1 y 3, y las columnas 3-5.


```r
my_matrix
```

```
##      [,1] [,2] [,3] [,4] [,5]
## [1,]    1    5    9   13   17
## [2,]    2    6   10   14   18
## [3,]    3    7   11   15   19
## [4,]    4    8   12   16   20
```

--


<i class="ion  ion-checkmark-circled "></i> La indexación de matrices se hace a partir del `[]`, separando con una coma (`,`) la selección de las **filas**, primero, de la selección de las **columnas**, segundo. En ambos casos según su **posición**:


```r
my_matrix[c(1, 3), 3:5]
```

```
##      [,1] [,2] [,3]
## [1,]    9   13   17
## [2,]   11   15   19
```

---
# Indexar data frames

<i class="ion  ion-alert "></i> En los data frames se suelen **seleccionar variables** o **filtrar casos**. Como ejemplo vamos a utilizar `my_df`. Para empezar vamos a subseleccionar la variable `var_num`.


```r
my_df
```

```
##   var_char   var_num var_logic
## 1        a 0.1527290     FALSE
## 2        b 1.7542460     FALSE
## 3        c 0.1653426      TRUE
## 4        d 0.3585551     FALSE
## 5        e 0.1919246      TRUE
```

---
# Filtrar columnas

<i class="ion  ion-checkmark-circled "></i> Las columnas se pueden indexar de hasta tres maneras diferentes, según se utilice el **nombre** (`var_num`) o la **posición** (`2`) de la variable en el data frame y el **tipo de indexación** `[,]` o `$`.



```r
my_df$var_num # produce un vector

my_df[, "var_num"] # produce un df
my_df[, 2] # produce un df
```

---
# Filtrar filas por posición

<i class="ion  ion-alert "></i> Ahora, además de escoger la variables `var_num` vamos a **seleccionar las filas** 1 y 3

--
        
        
<i class="ion  ion-checkmark-circled "></i> Para ello en el caso de haber utilizado `$` se emplean los **corchetes** `[]`; en el caso de haber utilizado corchetes `[,]`, se completa la **parte izquierda**:


```r
my_df$var_num[c(1, 3)] # produce un vector
my_df[c(1, 3), ]$var_num # produce un vector

my_df[c(1, 3), "var_num"] # produce un vector
my_df[c(1, 3), 2] # produce un vector
```

---

# Filtrar filas por carcterística

<i class="ion  ion-alert "></i> Lo más común es que las filas sean seleccionadas a partir de una **característica**, por ejemplo, si en `var_logic` es `FALSE`


```r
my_df
```

```
##   var_char   var_num var_logic
## 1        a 0.1527290     FALSE
## 2        b 1.7542460     FALSE
## 3        c 0.1653426      TRUE
## 4        d 0.3585551     FALSE
## 5        e 0.1919246      TRUE
```

---
# Filtrar filas por carcterística

<i class="ion  ion-checkmark-circled "></i> Para ello en el caso de haber utilizado `$` se emplean los **corchetes** `[]`, mientras que en el caso de haber utilizado corchetes `[,]`, se completa la **parte izquierda**:


```r
my_df$var_num[my_df$var_logic == FALSE] # produce un vector
my_df[my_df$var_logic == FALSE, ]$var_num # produce un vector

my_df[my_df$var_logic == FALSE, "var_num"] # produce un vector
my_df[my_df$var_logic == FALSE, 2] # produce un vector
```

---
# Quiz 📝

¿Cómo se seleccionarían los casos para los que `var_logic == TRUE` y que `var_num &lt; 0`?

--


```r
my_df[my_df$var_logic == TRUE &amp; my_df$var_num &lt; 0,]
```

```
## [1] var_char  var_num   var_logic
## &lt;0 rows&gt; (or 0-length row.names)
```

---
# Indexar lists

<i class="ion  ion-alert "></i> También puede ser necesario acceder a **elementos concretos de las listas**. Por ejemplo, queremos **extraer el data frame** de `my_list`:


```r
my_list
```

```
## $vector
##  Juan Marta Pablo 
##    10    20    10 
## 
## $df
##   var_char   var_num var_logic
## 1        a 0.1527290     FALSE
## 2        b 1.7542460     FALSE
## 3        c 0.1653426      TRUE
## 4        d 0.3585551     FALSE
## 5        e 0.1919246      TRUE
```
---
# Indexar lists

<i class="ion  ion-checkmark-circled "></i> Para acceder a los elementos de una lista existen dos sistemas: `$` y `[[]]`. El uso de `$` solo es posible **si los elementos de la lista tienen nombres**, de lo contrario habrá que seleccionarlos por su **posición** utilizando `[[]]`. Para comporbar si una lista tiene nombres se utiliza la función `names()`:


```r
names(my_list)
```

```
## [1] "vector" "df"
```



```r
my_list$df
```


```r
my_list[[2]]
```

```
##   var_char   var_num var_logic
## 1        a 0.1527290     FALSE
## 2        b 1.7542460     FALSE
## 3        c 0.1653426      TRUE
## 4        d 0.3585551     FALSE
## 5        e 0.1919246      TRUE
```


---
class: center, middle, inverse

# Modificar vectores

---
class: center, middle, inverse

# Operadores

---

# Operaciones aritméticas

Las **operaciones aritméticas** son las más comunes, `+`, `-`, `/`, `*`, `^`, `%%`, `%/%`. Estas operaciones tienen sentidos con vectores numéricos o factores ordinales. Para ejemplificar las opetaciones con vectores se crean dos vectores, el `v1` y `v2`:


```r
v1 &lt;- c(10, 5, 3)
v2 &lt;- c(4, 5, 20)
```

Y ahora operamos con ellos:


```r
v1+v2
```

```
## [1] 14 10 23
```

```r
v1/v2 
```

```
## [1] 2.50 1.00 0.15
```

---
# Operaciones relacionales

Los **operadores relacionales** (`&lt; &gt;`, `&lt;= &gt;=`, `==`, `!=`) funcionan con cualquier tipo de vector comparan dos elementos y devuelven un vector de tipo lógico como resultado:


```r
v1 == v2
```

```
## [1] FALSE  TRUE FALSE
```

```r
v1 &gt;= v2
```

```
## [1]  TRUE  TRUE FALSE
```

---
# Operaciones lógicas

Los **operadores lógicos** (`!`, `&amp;`, `|`) sirven para establecer relaciones entre elementos:


```r
v1 | v2 == c(10, 5, 20) 
```

```
## [1] TRUE TRUE TRUE
```

---

# Quiz 📝

¿Por qué el resultado de `v1 | v2 == c(10, 5, 20)` es igual a `TRUE TRUE TRUE` dados `V1` y `V2`?


```r
v1
```

```
## [1] 10  5  3
```

```r
v2
```

```
## [1]  4  5 20
```

```r
v1 | v2 == c(10, 5, 20) 
```

```
## [1] TRUE TRUE TRUE
```
---
class: center, middle, inverse

# Factors


---
# ⚠️ ⚠️ ⚠️ Atención ⚠️ ⚠️ ⚠️
.pull-left[### `R`

- Los factores son recodificados a &lt;br&gt;partir de los niveles

- La intervención de los factores en &lt;br&gt;
fórmulas lógicas se hace a traves de &lt;br&gt;
los niveles

- Ejemplo:


```r
region &lt;- recode(ciudad, 
                 "Valladolid" = "CyL",
                 "Salamanca" = "CyL")
```
]
.pull-rigt[
### `SPSS` o `Stata`

- Las variables son recodificadas en &lt;br&gt;base a los valores 

- La intervención de las variables en &lt;br&gt; 
fórmulas lógicas se hace a través de &lt;br&gt; 
los valores

- Ejemplo:


```r
# SPSS
recode ciudad (3 = 2) (else = copy) into region.
val labels region 1"Madrid" 2"CyL".
```
]
---
# Cambiar las etiquetas de un factor
#### `recode(x, ..., .default, .missing)` | `table(x, y)`

<i class="ion  ion-alert "></i> **Cambiar las etiquetas** de labels_factor_recode de forma que `"Desemp."` `\(\to\)` `"Desempleado"` y `"Retirado"` `\(\to\)` `"Jubilado"`.


--

<i class="ion  ion-checkmark-circled "></i> Una de las operaciones básicas con los factores es cambiar las etiquetas, para ello se utiliza la función `recode()`:


```r
labels_factor_recode &lt;- recode(labels_factor, 
                               "Desemp." = "Desempleado",
                               "Retirado" = "Jubilado")

table(labels_factor, labels_factor_recode)
```

```
##              labels_factor_recode
## labels_factor Desempleado Jubilado Trabaja
##      Desemp.            1        0       0
##      Retirado           0        1       0
##      Trabaja            0        0       3
```

---
# Reordenar los niveles de un factor

#### `fct_relevel(x, ...)`

<i class="ion  ion-alert "></i> Hay que **reordenar los niveles** de un factor. Asociar el nivel `"Trabaja"` con el valor `1`.


--

<i class="ion  ion-checkmark-circled "></i> Los niveles de un factor se pueden reordenar con la función `fct_relevel()`. Los niveles no explicitados en la función son colocados al final en el mismo orden que estaban: 


```r
levels(labels_factor_recode)
```

```
## [1] "Desempleado" "Jubilado"    "Trabaja"
```

```r
labels_factor_recode &lt;- fct_relevel(labels_factor_recode, "Trabaja")
levels(labels_factor_recode)
```

```
## [1] "Trabaja"     "Desempleado" "Jubilado"
```

---
# Combinar varios niveles de un factor

<i class="ion  ion-alert "></i> Hay que **recodificar el vector** `labels_factor_recode` de forma que `"Desempleado" = "No trabaja"` y `"Jubilado" = "No trabaja"`.

--

<i class="ion  ion-checkmark-circled "></i> La función `recode()` sirve para unir categorías de los factores, recodificar:


```r
labels_factor_recode &lt;- recode(labels_factor_recode, 
                               "Desempleado" = "No trabaja",
                               "Jubilado" = "No trabaja")

levels(labels_factor_recode)
```

```
## [1] "Trabaja"    "No trabaja"
```

---
# Momento *nerd* 🤓

Ahora sabemos modficar factores y hacer operaciones numéricas, pero los vectores que utilizamos se **encuentran generalmente dentro de un data frame**.    

--

&gt; ¿Cómo se modifica o crea un vector nuevo dentro de un data frame?

--


```r
my_df$new_var &lt;- my_df$var_num + 5
```

--

Utilizaremos el **operador `$` para acceder a los vectores** y modificarlos o emplearlos en otras transformaciones.

---
class: center, middle, inverse

# Cadenas de texto

---

# Cadenas de texto en `R`

Uno de los problemas usuales que se plantean al manipular datos es el manejo de las cadenas de texto del tipo:


```r
centros &lt;- c("CEIP María de Molina: Madrid", "IES Juan de la Cierva: Barcelona", "IES Juan Robles: Madrid")
```

---
# Localizar 

#### `str_locate(string, pattern)` | `str_locate_all(string, pattern)`

<i class="ion  ion-alert "></i> Para separar los los nombres de los centros educativos de los municipios es necesario localizar `:`.    



--
<i class="ion  ion-checkmark-circled "></i> En su forma más sencilla `str_locate()` permite localizar expresiones de texto (*p. ej.* `"Madrid"`) o símbolos antecedidos por una doble barra (*p. ej.* `"\\:"`). En este caso de lo que se trata es de localizar la posición de los dos puntos en cada cadena:


```r
str_locate(string = centros, pattern = "\\:")
```

```
##      start end
## [1,]    21  21
## [2,]    22  22
## [3,]    16  16
```


---
# Remplazar
#### `str_replace(string, pattern, replacement)` | `str_replace_all(string, pattern, replacement)`

<i class="ion  ion-alert "></i> Otra forma de limpiar texto es **sustituyendo** partes del mismo. Por ejemplo, en el caso de `centros` se podría sustituir `:` por la expresión `" de"`.     


--
<i class="ion  ion-checkmark-circled "></i> Para ello, la función `str_replace()` puede sustitir una expresión o símbolo por otros:


```r
str_replace(string = centros, pattern = "\\:", replacement = " de") # nótese el espacio en blanco en " de"
```

```
## [1] "CEIP María de Molina de Madrid"    
## [2] "IES Juan de la Cierva de Barcelona"
## [3] "IES Juan Robles de Madrid"
```


---
# Eliminar 

#### `str_remove(string, pattern)` | `str_remove_all(string, pattern)`

<i class="ion  ion-alert "></i> Otra forma operación habitual es la **eliminación** de determinados elementos con el fin de limpiar el texto. En el caso de `centros` se trata de eliminar los dos puntos (`:`).   


--
<i class="ion  ion-checkmark-circled "></i> Para ello se utilizan las funciones `str_remove()` para eliminar la primera ocurrencia o `str_remove_all()` para eliminar todas las ocurrencias de la expresión:


```r
str_remove(string = centros, pattern = "\\:")
```

```
## [1] "CEIP María de Molina Madrid"     "IES Juan de la Cierva Barcelona"
## [3] "IES Juan Robles Madrid"
```

---
# Seleccionar

#### `str_sub(string, start, end)`

<i class="ion  ion-alert "></i> La otra operación básica consiste en **seleccionar fragmentos** de las cadenas de texto. En este caso se trata, por ejemplo, de seleccionar el nombre de los centros omitiendo las ciudades.     


--
<i class="ion  ion-checkmark-circled "></i> En este caso habría que emplear la función `str_sub()`, estableciendo el comienzo en el caracter `1` y el final en el caracter en el que se localiza `:` menos `1`.


```r
ends &lt;- str_locate(string = centros, pattern = "\\:")[,1]

str_sub(string = centros, start = 1, end = ends-1)
```

```
## [1] "CEIP María de Molina"  "IES Juan de la Cierva" "IES Juan Robles"
```

---
# Quiz 📝

¿Por qué es necesario utilizar `[,1]` al final de la expresión `ends &lt;- str_locate(centros, "\\:")[,1]` para que `str_sub(string = centros, start = 1, end = ends-1)` funcione?

--


```r
str_locate(string = centros, pattern = "\\:")
```

```
##      start end
## [1,]    21  21
## [2,]    22  22
## [3,]    16  16
```


---
class: inverse, middle, center

# Formatear fechas

---
# Formatear fechas

#### `parse_date_time()`

<i class="ion  ion-alert "></i> En ocasiones las **fechas son cargadas como texto** y deben ser convertidas a formato fechas.


```r
dates &lt;- c("10/07/2019", "11/08/2019")
class(dates)
```

```
## [1] "character"
```
     
     

--
<i class="ion  ion-checkmark-circled "></i> Para convertir a fecha el texto se puede utilizar la función `parse_date_time()`, especificando el formato de la fecha del tipo `"dmy"` (día-mes-año):


```r
lubridate::parse_date_time(x = dates, orders = "dmy")
```

```
## [1] "2019-07-10 UTC" "2019-08-11 UTC"
```

---
class: inverse, middle, center

# Valores perdidos

---
# Los valores perdidos en `R`

En `R` los **valores perdidos** toman la forma de `NA`, perdidos por el sistema. Para que códigos de encuesta como el 98 o 99 fueran tratados como perdidos habría que convertirlos en `NA`. Para ejemplificar el tratamiento vamos a partir del siguiente vector que representa la variable `age`:


```r
# variable age en la que 999 es NC
age &lt;- c(36, 44, NA, 999, 67, NA)
```

---
# Localizar los valores perdidos

#### `is.na(x)` | `sum(x)` 

<i class="ion  ion-alert "></i> Un problema es saber cuantos valores perdidos hay en cada objeto.    



--


<i class="ion  ion-checkmark-circled "></i> Utilizar la función `is.na()` en combinación con `sum()`. Por un lado, `is.na()` produce un vector lógico en el que `TRUE` se refiere a los valores perdidos. Un vector lógico se puede transformar en numérico, en el que `TRUE` es 1 y `FALSE` es 0. 


```r
is.na(age)
```

```
## [1] FALSE FALSE  TRUE FALSE FALSE  TRUE
```

```r
sum(is.na(age))
```

```
## [1] 2
```
---
# Convertir valores en perdidos

<i class="ion  ion-alert "></i> En ocasiones hay valores que deben ser transformados en perdidos, por ejemplo, en el caso de `age` el código `999`.    


--

<i class="ion  ion-checkmark-circled "></i> Seleccionar los casos que tengan código `999` y asignarles `NA`.


```r
age[age == 999] &lt;- NA 
age
```

```
## [1] 36 44 NA NA 67 NA
```

---
# Tratar los valores perdidos

#### `mean(x, na.rm)`

<i class="ion  ion-alert "></i> También hay que tratar los valores perdidos para el análisis. Al usarlo en algunas funciones, el resultado en `NA`:


```r
mean(age)
```

```
## [1] NA
```

--
<i class="ion  ion-checkmark-circled "></i> En las funciones como `mean()` existe una opción `na.rm` que cuando se le asigna el valor `TRUE` excluye los valores `NA` del análisis:


```r
mean(age, na.rm = TRUE)
```

```
## [1] 49
```

---
class: center, middle, inverse

# Transformar objetos

---
# Paso 1: ¿qué **tipo de objeto** es?

#### `class(x)` 

La función `class()` devuelve el tipo de objeto:


```r
class(my_vector)
```

```
## [1] "numeric"
```


```r
class(my_list)
```

```
## [1] "list"
```


---
# Paso 1: ¿qué **tipo de objeto** es?

Por su parte, `str()` nos informa de la estructura del objeto:


```r
str(my_vector)
```

```
##  Named num [1:3] 10 20 10
##  - attr(*, "names")= chr [1:3] "Juan" "Marta" "Pablo"
```


```r
str(my_list)
```

```
## List of 2
##  $ vector: Named num [1:3] 10 20 10
##   ..- attr(*, "names")= chr [1:3] "Juan" "Marta" "Pablo"
##  $ df    :'data.frame':	5 obs. of  3 variables:
##   ..$ var_char : Factor w/ 5 levels "a","b","c","d",..: 1 2 3 4 5
##   ..$ var_num  : num [1:5] 0.153 1.754 0.165 0.359 0.192
##   ..$ var_logic: logi [1:5] FALSE FALSE TRUE FALSE TRUE
```

---
# Paso 2: transformar objetos

Las funciones de tipo `as.data.frame()` sirven para transformar los objetos de `R`, sin embargo todas las transformaciones no son posibles. Principales transformaciones:  
 


```r
as.character()
as.factor()
as.numeric()
as.data.frame()
as.list()
```

---
#character `\(\to\)` numeric


<i class="ion  ion-alert "></i> Tras cargar un conjunto de datos una varaible de tipo numérico, como puede ser edad, aparece **almacenada como texto**. El objetivo es calcular la media.


```r
numbers &lt;- c("19.0", "22.0", "33.0")
```
--

Partimos de un vector de tipo character que contiene números:


```r
mean(numbers)
```

```
## Warning in mean.default(numbers): argument is not numeric or logical:
## returning NA
```

```
## [1] NA
```
      
---
# character `\(\to\)` numeric

<i class="ion  ion-checkmark-circled "></i> Transformar el vector en numeric:


```r
numbers_new &lt;- as.numeric(numbers)
mean(numbers_new)
```

```
## [1] 24.66667
```

---
#character `\(\to\)` factor

#### `as.factor(x)`

<i class="ion  ion-alert "></i> R trata los **factores de forma específica** en algunos procedimientos, como por ejemplo en las regresiones `lm()`. Las variables de tipo factor son dicotomizadas, sin embargo, puede ocurrir que al cargar el conjunto de datos la variable categórica aparezca alamacenada como character.    


--
Partimos de un vector de tipo *character*, en este caso ciudades.


```r
char &lt;- c("Madrid", "Barcelona", "Madrid")
str(char)
```

```
##  chr [1:3] "Madrid" "Barcelona" "Madrid"
```
       
--
<i class="ion  ion-checkmark-circled "></i> Transformar la variable en factor usando `as.factor()`:


```r
factor_new &lt;- as.factor(char)
str(factor_new)
```

```
##  Factor w/ 2 levels "Barcelona","Madrid": 2 1 2
```

---
class: inverse, middle, center

# Proyecto

---
# Proyecto y `R` *workflow*

---
# Help!

#### `help()`
Ayuda con las funciones:  


```r
help(mean)
?mean
```

---
# Recursos: encontrar la función
    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script>var slideshow = remark.create({
"ratio": "16:9",
"highlightStyle": "idea",
"highlightLines": true,
"countIncrementalSlides": false
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();</script>

<script>
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
